<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Block Device Drivers for Littlefs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Block Device Drivers for Littlefs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__group__lfs__sd__bd.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SD Card Block Device Driver</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<ul>
<li>Implements the block device driver functions for the SD card (card mode) for use with littlefs API.</li>
<li>Makes use of the Secure Digital Host Controller (SDHC) HAL driver.</li>
<li>Provides <a class="el" href="group__group__lfs__sd__bd.html#gad4212391d0aacbfc6ea5c77c2eed513c">lfs_sd_bd_lock()</a> and <a class="el" href="group__group__lfs__sd__bd.html#ga716190b32d03e242da72c53f03ee7f8e">lfs_sd_bd_unlock()</a> functions for use with lfs_config structure when LFS_THREADSAFE macro is defined.</li>
<li>Thread safety is implemented using only one mutex instance. This means that a thread will get blocked while trying to perform an operation regardless of which SDHC hardware instance it is accessing until another thread completes that operation.</li>
</ul>
<p><b>Note:</b></p><ul>
<li>Add DEFINE=LFS_THREADSAFE in the Makefile when thread-safety is required.</li>
<li>Add COMPONENTS=RTOS_AWARE for enabling the RTOS-friendly features of the underlying SDHC HAL driver. An example of such feature is that the read function waits on a semaphore until read completion is indicated through an interrupt. </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structlfs__sd__bd__config__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#structlfs__sd__bd__config__t">lfs_sd_bd_config_t</a></td></tr>
<tr class="memdesc:structlfs__sd__bd__config__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure for the SD block device.  <a href="group__group__lfs__sd__bd.html#structlfs__sd__bd__config__t">More...</a><br /></td></tr>
<tr class="separator:structlfs__sd__bd__config__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga660549d6086f7305914ede9d836fc000"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#ga660549d6086f7305914ede9d836fc000">LFS_SD_BD_TRACE</a>(...)</td></tr>
<tr class="memdesc:ga660549d6086f7305914ede9d836fc000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable trace for this driver by defining this macro.  <a href="#ga660549d6086f7305914ede9d836fc000">More...</a><br /></td></tr>
<tr class="separator:ga660549d6086f7305914ede9d836fc000"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga16ca46e85a98b5d1a1f183df6a8940a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#ga16ca46e85a98b5d1a1f183df6a8940a6">lfs_sd_bd_get_default_config</a> (<a class="el" href="group__group__lfs__sd__bd.html#structlfs__sd__bd__config__t">lfs_sd_bd_config_t</a> *bd_cfg)</td></tr>
<tr class="memdesc:ga16ca46e85a98b5d1a1f183df6a8940a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the default configuration for the block device for use with the <a class="el" href="group__group__lfs__sd__bd.html#ga49d5cf64bd2240c614cca4e450e72ade">lfs_sd_bd_create()</a> function.  <a href="#ga16ca46e85a98b5d1a1f183df6a8940a6">More...</a><br /></td></tr>
<tr class="separator:ga16ca46e85a98b5d1a1f183df6a8940a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d5cf64bd2240c614cca4e450e72ade"><td class="memItemLeft" align="right" valign="top">cy_rslt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#ga49d5cf64bd2240c614cca4e450e72ade">lfs_sd_bd_create</a> (struct lfs_config *lfs_cfg, const <a class="el" href="group__group__lfs__sd__bd.html#structlfs__sd__bd__config__t">lfs_sd_bd_config_t</a> *bd_cfg)</td></tr>
<tr class="memdesc:ga49d5cf64bd2240c614cca4e450e72ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the SD card interface and populates the lfs_config structure with the default values.  <a href="#ga49d5cf64bd2240c614cca4e450e72ade">More...</a><br /></td></tr>
<tr class="separator:ga49d5cf64bd2240c614cca4e450e72ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga739c5699c697fc686d7754ad23561614"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#ga739c5699c697fc686d7754ad23561614">lfs_sd_bd_destroy</a> (const struct lfs_config *lfs_cfg)</td></tr>
<tr class="memdesc:ga739c5699c697fc686d7754ad23561614"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the SD interface and frees the resources.  <a href="#ga739c5699c697fc686d7754ad23561614">More...</a><br /></td></tr>
<tr class="separator:ga739c5699c697fc686d7754ad23561614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29d45df1a3828a0bf20a96909536bce8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#ga29d45df1a3828a0bf20a96909536bce8">lfs_sd_bd_read</a> (const struct lfs_config *lfs_cfg, lfs_block_t block, lfs_off_t off, void *buffer, lfs_size_t size)</td></tr>
<tr class="memdesc:ga29d45df1a3828a0bf20a96909536bce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data starting from a given block and offset.  <a href="#ga29d45df1a3828a0bf20a96909536bce8">More...</a><br /></td></tr>
<tr class="separator:ga29d45df1a3828a0bf20a96909536bce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeb31192106b671a22009dd93b8f4647"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#gadeb31192106b671a22009dd93b8f4647">lfs_sd_bd_prog</a> (const struct lfs_config *lfs_cfg, lfs_block_t block, lfs_off_t off, const void *buffer, lfs_size_t size)</td></tr>
<tr class="memdesc:gadeb31192106b671a22009dd93b8f4647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Programs or writes the data starting from a given block and offset.  <a href="#gadeb31192106b671a22009dd93b8f4647">More...</a><br /></td></tr>
<tr class="separator:gadeb31192106b671a22009dd93b8f4647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513c4bfda6befdc610a0f5928521fdd6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#ga513c4bfda6befdc610a0f5928521fdd6">lfs_sd_bd_erase</a> (const struct lfs_config *lfs_cfg, lfs_block_t block)</td></tr>
<tr class="memdesc:ga513c4bfda6befdc610a0f5928521fdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a given block.  <a href="#ga513c4bfda6befdc610a0f5928521fdd6">More...</a><br /></td></tr>
<tr class="separator:ga513c4bfda6befdc610a0f5928521fdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8313c3e914560b9b56c1107256ceb674"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#ga8313c3e914560b9b56c1107256ceb674">lfs_sd_bd_sync</a> (const struct lfs_config *lfs_cfg)</td></tr>
<tr class="memdesc:ga8313c3e914560b9b56c1107256ceb674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the write cache when present.  <a href="#ga8313c3e914560b9b56c1107256ceb674">More...</a><br /></td></tr>
<tr class="separator:ga8313c3e914560b9b56c1107256ceb674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4212391d0aacbfc6ea5c77c2eed513c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#gad4212391d0aacbfc6ea5c77c2eed513c">lfs_sd_bd_lock</a> (const struct lfs_config *lfs_cfg)</td></tr>
<tr class="memdesc:gad4212391d0aacbfc6ea5c77c2eed513c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks or gets the mutex associated with this block device.  <a href="#gad4212391d0aacbfc6ea5c77c2eed513c">More...</a><br /></td></tr>
<tr class="separator:gad4212391d0aacbfc6ea5c77c2eed513c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga716190b32d03e242da72c53f03ee7f8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__lfs__sd__bd.html#ga716190b32d03e242da72c53f03ee7f8e">lfs_sd_bd_unlock</a> (const struct lfs_config *lfs_cfg)</td></tr>
<tr class="memdesc:ga716190b32d03e242da72c53f03ee7f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks or sets the mutex associated with this block device.  <a href="#ga716190b32d03e242da72c53f03ee7f8e">More...</a><br /></td></tr>
<tr class="separator:ga716190b32d03e242da72c53f03ee7f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structlfs__sd__bd__config__t" id="structlfs__sd__bd__config__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structlfs__sd__bd__config__t">&#9670;&nbsp;</a></span>lfs_sd_bd_config_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct lfs_sd_bd_config_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="aa2a813d6cff64fd3c32b7d46939f5bda"></a>cyhal_sdhc_t</td>
<td class="fieldname">
sdhc_obj</td>
<td class="fielddoc">
Object for use with the SDHC HAL driver. </td></tr>
<tr><td class="fieldtype">
<a id="a99748d778371eb2e628ad87ec15b25a9"></a>cyhal_sdhc_config_t</td>
<td class="fieldname">
sdhc_config</td>
<td class="fielddoc">
Card configuration structure to be passed to the HAL driver. </td></tr>
<tr><td class="fieldtype">
<a id="a5fb3351ec9bbefed2c2428bf42e2b93d"></a>cyhal_gpio_t</td>
<td class="fieldname">
cmd</td>
<td class="fielddoc">
The pin connected to the command signal. </td></tr>
<tr><td class="fieldtype">
<a id="afdfc71e5d179bf38c3778cfc910581aa"></a>cyhal_gpio_t</td>
<td class="fieldname">
clk</td>
<td class="fielddoc">
The pin connected to the clock signal. </td></tr>
<tr><td class="fieldtype">
<a id="a60a5451967c607a48910c8b2d0508494"></a>cyhal_gpio_t</td>
<td class="fieldname">
data0</td>
<td class="fielddoc">
The pin connected to the data0 signal. </td></tr>
<tr><td class="fieldtype">
<a id="a6a1ec5be5132a18734bc3034b9196b81"></a>cyhal_gpio_t</td>
<td class="fieldname">
data1</td>
<td class="fielddoc">
The pin connected to the data1 signal. </td></tr>
<tr><td class="fieldtype">
<a id="a50c6ba006780020804cfb238bad8afb1"></a>cyhal_gpio_t</td>
<td class="fieldname">
data2</td>
<td class="fielddoc">
The pin connected to the data2 signal. </td></tr>
<tr><td class="fieldtype">
<a id="a5d83d158d8364fd1ed1a2296a346d12a"></a>cyhal_gpio_t</td>
<td class="fieldname">
data3</td>
<td class="fielddoc">
The pin connected to the data3 signal. </td></tr>
<tr><td class="fieldtype">
<a id="aed23a0f19c7be93b6a9758bd1513ac35"></a>cyhal_gpio_t</td>
<td class="fieldname">
data4</td>
<td class="fielddoc">
The pin connected to the data4 signal; pass NC when unused. </td></tr>
<tr><td class="fieldtype">
<a id="ab16a88300010d8746849068759361a6a"></a>cyhal_gpio_t</td>
<td class="fieldname">
data5</td>
<td class="fielddoc">
The pin connected to the data5 signal; pass NC when unused. </td></tr>
<tr><td class="fieldtype">
<a id="a0f4f7896cfc424c9796666d908994582"></a>cyhal_gpio_t</td>
<td class="fieldname">
data6</td>
<td class="fielddoc">
The pin connected to the data6 signal; pass NC when unused. </td></tr>
<tr><td class="fieldtype">
<a id="af49bc3ecb342d6047f49ec1b12547443"></a>cyhal_gpio_t</td>
<td class="fieldname">
data7</td>
<td class="fielddoc">
The pin connected to the data7 signal; pass NC when unused. </td></tr>
<tr><td class="fieldtype">
<a id="aef85b526b08fc77e04b582f50bed0e14"></a>cyhal_gpio_t</td>
<td class="fieldname">
card_detect</td>
<td class="fielddoc">
The pin connected to the card detect signal. </td></tr>
<tr><td class="fieldtype">
<a id="a65b5d404b0163f1d33bb1b385a2c7079"></a>cyhal_gpio_t</td>
<td class="fieldname">
io_volt_sel</td>
<td class="fielddoc">
The pin connected to the voltage select signal. </td></tr>
<tr><td class="fieldtype">
<a id="a8d3ae5078994837264ebb850c9a50cdf"></a>cyhal_gpio_t</td>
<td class="fieldname">
card_if_pwr_en</td>
<td class="fielddoc">
The pin connected to the card interface power enable signal. </td></tr>
<tr><td class="fieldtype">
<a id="add99e56a0aa16b3d6d1c8ca15aebe7c0"></a>cyhal_gpio_t</td>
<td class="fieldname">
card_mech_write_prot</td>
<td class="fielddoc">
The pin connected to the write protect signal. </td></tr>
<tr><td class="fieldtype">
<a id="a68c02e6971243a7fb5871d3fb63e83a3"></a>cyhal_gpio_t</td>
<td class="fieldname">
led_ctrl</td>
<td class="fielddoc">
The pin connected to the LED control signal. </td></tr>
<tr><td class="fieldtype">
<a id="afaace2ec96743dbde0dc39ac560d4017"></a>cyhal_gpio_t</td>
<td class="fieldname">
card_emmc_reset</td>
<td class="fielddoc">
The pin connected to the eMMC card reset signal. </td></tr>
<tr><td class="fieldtype">
<a id="abf1b0a68dc3cef2d433d1534564d3471"></a>cyhal_clock_t *</td>
<td class="fieldname">
block_clk</td>
<td class="fielddoc">
The clock to use can be shared, if not provided a new clock will be allocated. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga660549d6086f7305914ede9d836fc000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga660549d6086f7305914ede9d836fc000">&#9670;&nbsp;</a></span>LFS_SD_BD_TRACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LFS_SD_BD_TRACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable trace for this driver by defining this macro. </p>
<p>You must also define the global trace enable macro LFS_YES_TRACE. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga16ca46e85a98b5d1a1f183df6a8940a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16ca46e85a98b5d1a1f183df6a8940a6">&#9670;&nbsp;</a></span>lfs_sd_bd_get_default_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lfs_sd_bd_get_default_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__lfs__sd__bd.html#structlfs__sd__bd__config__t">lfs_sd_bd_config_t</a> *&#160;</td>
          <td class="paramname"><em>bd_cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches the default configuration for the block device for use with the <a class="el" href="group__group__lfs__sd__bd.html#ga49d5cf64bd2240c614cca4e450e72ade">lfs_sd_bd_create()</a> function. </p>
<p>Default configuration: SD card (card mode) with 3.3V signalling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bd_cfg</td><td>Pointer to the block device configuration structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49d5cf64bd2240c614cca4e450e72ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49d5cf64bd2240c614cca4e450e72ade">&#9670;&nbsp;</a></span>lfs_sd_bd_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cy_rslt_t lfs_sd_bd_create </td>
          <td>(</td>
          <td class="paramtype">struct lfs_config *&#160;</td>
          <td class="paramname"><em>lfs_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__lfs__sd__bd.html#structlfs__sd__bd__config__t">lfs_sd_bd_config_t</a> *&#160;</td>
          <td class="paramname"><em>bd_cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the SD card interface and populates the lfs_config structure with the default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfs_cfg</td><td>Pointer to the lfs_config structure that will be initialized with the default values. </td></tr>
    <tr><td class="paramname">bd_cfg</td><td>Pointer to the block device configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>CY_RSLT_SUCCESS if the initialization was successful; an error code otherwise. </dd></dl>

</div>
</div>
<a id="ga739c5699c697fc686d7754ad23561614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga739c5699c697fc686d7754ad23561614">&#9670;&nbsp;</a></span>lfs_sd_bd_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lfs_sd_bd_destroy </td>
          <td>(</td>
          <td class="paramtype">const struct lfs_config *&#160;</td>
          <td class="paramname"><em>lfs_cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initializes the SD interface and frees the resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfs_cfg</td><td>Pointer to the lfs_config structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga29d45df1a3828a0bf20a96909536bce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29d45df1a3828a0bf20a96909536bce8">&#9670;&nbsp;</a></span>lfs_sd_bd_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lfs_sd_bd_read </td>
          <td>(</td>
          <td class="paramtype">const struct lfs_config *&#160;</td>
          <td class="paramname"><em>lfs_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lfs_block_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lfs_off_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lfs_size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data starting from a given block and offset. </p>
<p>This is a blocking function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfs_cfg</td><td>Pointer to the lfs_config structure. </td></tr>
    <tr><td class="paramname">block</td><td>Block number from which read should begin. </td></tr>
    <tr><td class="paramname">off</td><td>Offset in the block from which read should begin. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to the buffer to store the data read from the memory. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the read was successful; -1 otherwise. </dd></dl>

</div>
</div>
<a id="gadeb31192106b671a22009dd93b8f4647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeb31192106b671a22009dd93b8f4647">&#9670;&nbsp;</a></span>lfs_sd_bd_prog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lfs_sd_bd_prog </td>
          <td>(</td>
          <td class="paramtype">const struct lfs_config *&#160;</td>
          <td class="paramname"><em>lfs_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lfs_block_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lfs_off_t&#160;</td>
          <td class="paramname"><em>off</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lfs_size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Programs or writes the data starting from a given block and offset. </p>
<p>The block must have been previously erased. This is a blocking function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfs_cfg</td><td>Pointer to the lfs_config structure. </td></tr>
    <tr><td class="paramname">block</td><td>Block number from which write should begin. </td></tr>
    <tr><td class="paramname">off</td><td>Offset in the block from which write should begin. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to the buffer that contains the data to be written. </td></tr>
    <tr><td class="paramname">size</td><td>Number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the write was successful; -1 otherwise. </dd></dl>

</div>
</div>
<a id="ga513c4bfda6befdc610a0f5928521fdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga513c4bfda6befdc610a0f5928521fdd6">&#9670;&nbsp;</a></span>lfs_sd_bd_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lfs_sd_bd_erase </td>
          <td>(</td>
          <td class="paramtype">const struct lfs_config *&#160;</td>
          <td class="paramname"><em>lfs_cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lfs_block_t&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases a given block. </p>
<p>SD/MMC cards do not require explicit erase before programming since the card controllers perform erase internally during programming. Therefore, this API is not to be used with the erase() of lfs_config structure. However, user can directly call this API to erase specific blocks of a memory card. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfs_cfg</td><td>Pointer to the lfs_config structure. </td></tr>
    <tr><td class="paramname">block</td><td>Block number to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the erase was successful; -1 otherwise. </dd></dl>

</div>
</div>
<a id="ga8313c3e914560b9b56c1107256ceb674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8313c3e914560b9b56c1107256ceb674">&#9670;&nbsp;</a></span>lfs_sd_bd_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lfs_sd_bd_sync </td>
          <td>(</td>
          <td class="paramtype">const struct lfs_config *&#160;</td>
          <td class="paramname"><em>lfs_cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the write cache when present. </p>
<p>Simply returns zero because the SDHC block does not have any write cache. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfs_cfg</td><td>Pointer to the lfs_config structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always 0. </dd></dl>

</div>
</div>
<a id="gad4212391d0aacbfc6ea5c77c2eed513c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4212391d0aacbfc6ea5c77c2eed513c">&#9670;&nbsp;</a></span>lfs_sd_bd_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lfs_sd_bd_lock </td>
          <td>(</td>
          <td class="paramtype">const struct lfs_config *&#160;</td>
          <td class="paramname"><em>lfs_cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks or gets the mutex associated with this block device. </p>
<p>This function is internally called by the littlefs APIs when LFS_THREADSAFE is defined. User should call this function directly only if the other block device functions are directly called and thread-safety is required in that case. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfs_cfg</td><td>Pointer to the lfs_config structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if locking was successful; -1 otherwise. </dd></dl>

</div>
</div>
<a id="ga716190b32d03e242da72c53f03ee7f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga716190b32d03e242da72c53f03ee7f8e">&#9670;&nbsp;</a></span>lfs_sd_bd_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lfs_sd_bd_unlock </td>
          <td>(</td>
          <td class="paramtype">const struct lfs_config *&#160;</td>
          <td class="paramname"><em>lfs_cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks or sets the mutex associated with this block device. </p>
<p>This function is internally called by the littlefs APIs when LFS_THREADSAFE is defined. User should call this function directly only if the other block device functions are directly called and thread-safety is required in that case. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lfs_cfg</td><td>Pointer to the lfs_config structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if unlocking was successful; -1 otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>Block Device Drivers for Littlefs</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
